<#@ template language="C#" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Runtime.CompilerServices" #>
<#@ import namespace="Routine.Client" #>

<# foreach(var model in OperationalModels) { #>

namespace <#= model.GetNamespace(Mode.Interface) #>
{
	public interface <#= model.GetName(Mode.Interface) #>
	{
	<# foreach(var member in model.Members) { #>

		<#= member.ReturnModel.GetFullName() #> <#= member.GetName(Mode.Interface) #> { get; }
	<# } #>

	<# foreach(var operation in model.Operations) { #>
		<# foreach(var group in operation.Groups) { #>

		<#= operation.ReturnModel.GetFullName() #> <#= operation.GetName(Mode.Interface) #>(<#= string.Join(", ", group.Select(p => p.ParameterModel.GetFullName() + " " + p.GetName(Mode.Interface))) #>);
		<# } #>
	<# } #>

		void Invalidate();
	}
}

namespace <#= model.GetNamespace(Mode.Concrete) #>
{
	internal class <#= model.GetName(Mode.Concrete) #> : <#= model.GetFullName(Mode.Interface) #>
	{
		internal <#= Type<Robject>() #> Robject { get; private set; }
		internal <#= model.GetName(Mode.Concrete) #>(<#= Type<Robject>() #> robject)
		{
			Robject = robject;
		}

	<# foreach(var member in model.Members) { #>

		<#= member.ReturnModel.GetFullName() #> <#= model.GetFullName(Mode.Interface) #>.<#= member.GetName(Mode.Interface) #>
		{
			get
			{
				var result = Robject["<#= member.Id #>"].Get();
				
				return <#= member.ReturnModel.RenderRvariableToObject("result", "Robject.Application") #>;
			}
		}
	<# } #>

	<# foreach(var operation in model.Operations) { #>
		<# foreach(var group in operation.Groups) { #>

		<#= operation.ReturnModel.GetFullName() #> <#= model.GetFullName(Mode.Interface) #>.<#= operation.GetName(Mode.Interface) #>
			(<#= string.Join(", ", group.Select(p => p.ParameterModel.GetFullName() + " " + p.GetName(Mode.Interface))) #>)
		{
			var __result = Robject.Perform
				(
				"<#= operation.Id #>"
			<# foreach(var parameter in group) { #>
				, <#= parameter.ParameterModel.RenderObjectToRvariable(parameter.Id, parameter.GetName(Mode.Interface), "Robject.Application") #>
			<# } #>

				)
			;
			<# if(!operation.ReturnModel.IsVoid) { #>

			return <#= operation.ReturnModel.RenderRvariableToObject("__result", "Robject.Application") #>;
			<# } #>

		}
		<# } #>
	<# } #>

		void <#= model.GetFullName(Mode.Interface) #>.Invalidate()
		{
			Robject.Invalidate();
		}
		
		public override string ToString()
		{
			return string.Format("{0} ({1})", Robject.Value, Robject.Id);
		}

		public override bool Equals(object obj)
		{
			if(obj == null)
				return false;
			if(ReferenceEquals(this, obj))
				return true;
			if(obj.GetType() != typeof(<#= model.GetName(Mode.Concrete) #>))
				return false;

			var other = (<#= model.GetName(Mode.Concrete) #>)obj;
			
			return Robject.Equals(other.Robject);
		}
		
		public override int GetHashCode()
		{
			return Robject.GetHashCode();
		}
	}
}

<# } #>

<# foreach(var model in InitializableOperationalModels) { #>

namespace <#= model.GetNamespace(Mode.FactoryInterface) #>
{
	public interface <#= model.GetName(Mode.FactoryInterface) #>
	{
		<# foreach(var group in model.Initializer.Groups) { #>

		<#= model.GetFullName(Mode.Interface) #> New
			(<#= string.Join(", ", group.Select(p => p.ParameterModel.GetFullName() + " " + p.GetName(Mode.FactoryInterface))) #>);
		<# } #>

	}
}

namespace <#= model.GetNamespace(Mode.Factory) #>
{
	internal class <#= model.GetName(Mode.Factory) #> : <#= model.GetFullName(Mode.FactoryInterface) #>
	{
		internal <#= Type<Rapplication>() #> Rapplication { get; private set; }

		public <#= model.GetName(Mode.Factory) #>(<#= Type<Rapplication>() #> rapplication)
		{
			Rapplication = rapplication;
		}
		
		<# foreach(var group in model.Initializer.Groups) { #>

		<#= model.GetFullName(Mode.Interface) #> <#= model.GetFullName(Mode.FactoryInterface) #>.New
			(<#= string.Join(", ", group.Select(p => p.ParameterModel.GetFullName() + " " + p.GetName(Mode.FactoryInterface))) #>)
		{
			var robject = Rapplication
				.Init("<#= model.Id #>"
			<# foreach(var parameter in group) { #>

					, <#= parameter.ParameterModel.RenderObjectToRvariable(parameter.Id, parameter.GetName(Mode.FactoryInterface), "Rapplication") #>
			<# } #>

				);

			return new <#= model.GetFullName(Mode.Concrete) #>(robject);
		}
		<# } #>

	}
}
<# } #>

<# foreach(var model in InitializeOnlyStructModels) { #>

namespace <#= model.GetNamespace(Mode.InitializeOnlyStruct) #>
{
	public struct <#= model.GetName(Mode.InitializeOnlyStruct) #>
	{
		private readonly int group;
		<# foreach(var parameter in model.Initializer.Parameters) { #>

		public <#= parameter.ParameterModel.GetFullName() #> <#= parameter.GetName(Mode.InitializeOnlyStructProperty) #> { get; private set; }
		<# } #>

		<# var groups = model.Initializer.Groups; #>
		<# for(int i = 0; i < groups.Count; i++) { #>
			<# var group = groups[i]; #>

		public <#= model.GetName(Mode.InitializeOnlyStruct) #>
			(<#= string.Join(", ", group.Select(p => p.ParameterModel.GetFullName() + " " + p.GetName(Mode.InitializeOnlyStruct))) #>) : this()
		{
			this.group = <#= i #>;
			<# foreach(var parameter in group) { #>
			
			<#= parameter.GetName(Mode.InitializeOnlyStructProperty) #> = <#= parameter.GetName(Mode.InitializeOnlyStruct) #>;
			<# } #>

		}
		<# } #>

		internal <#= Type<Robject>() #> ToRobject(<#= Type<Rtype>() #> rtype)
		{
			var initParams = new <#= Type<List<Rvariable>>() #>();
			
			<# for(int i = 0; i < groups.Count; i++) { #>
				<# var group = groups[i]; #>
			
			<#= i > 0 ? "else " : string.Empty #>if(group == <#= i #>)
			{
				<# foreach(var parameter in group) { #>
			
				initParams.Add(<#= parameter.ParameterModel.RenderObjectToRvariable(parameter.Id, parameter.GetName(Mode.InitializeOnlyStructProperty), "rtype.Application") #>);
				<# } #>

			}
			<# } #>
			
			return rtype.Init(initParams);
		}
	}
}

<# } #>

<# foreach(var model in EnumModels) { #>

namespace <#= model.GetNamespace(Mode.Enum) #>
{
	public enum <#= model.GetName(Mode.Enum) #>
	{
	<# foreach(var staticInstance in model.Type.StaticInstances) { #>
	
		<#= staticInstance.GetEnumMemberName() #>,
	<# } #>

	}
}

namespace <#= model.GetNamespace(Mode.EnumConverter) #>
{
	internal static class <#= model.GetName(Mode.EnumConverter) #>
	{
		private static readonly <#= Type<Dictionary<object, string>>() #> ids = new <#= Type<Dictionary<object, string>>() #>();
		private static readonly <#= Type<Dictionary<string, object>>() #> values = new <#= Type<Dictionary<string, object>>() #>();

		static <#= model.GetName(Mode.EnumConverter) #>()
		{
	<# foreach(var staticInstance in model.Type.StaticInstances) { #>
	
			ids.Add(<#= model.GetFullName(Mode.Enum) + "." + staticInstance.GetEnumMemberName() #>, "<#= staticInstance.Id #>");
	<# } #>

	<# foreach(var staticInstance in model.Type.StaticInstances) { #>
	
			values.Add("<#= staticInstance.Id #>", <#= model.GetFullName(Mode.Enum) + "." + staticInstance.GetEnumMemberName() #>);
	<# } #>

		}

		internal static <#= Type<Robject>() #> ToRobject(<#= model.GetFullName(Mode.Enum) #> value, <#= Type<Rtype>() #> rtype)
		{
			return rtype.Get(ids[value]);
		}

		internal static <#= model.GetFullName(Mode.Enum) #> ToEnum(<#= Type<Robject>() #> robject)
		{
			return (<#= model.GetFullName(Mode.Enum) #>)values[robject.Id];
		}
	}
}

<# } #>

namespace <#= Application.DefaultNamespace #>
{
	public interface I<#= ApiName#>
	{
		T Get<T>(string instanceId);
		object Get(<#= Type<Type>() #> type, string instanceId);

		T Get<T>();
		object Get(<#= Type<Type>() #> type);
	}

	public class <#= ApiName #> : I<#= ApiName #>
	{
		private readonly <#= Type<Rapplication>() #> rapplication;

		public <#= ApiName #>(<#= Type<Rapplication>() #> rapplication)
		{
			this.rapplication = rapplication;
		}


		T I<#= ApiName #>.Get<T>(string instanceId) { return (T)((I<#= ApiName #>)this).Get(typeof(T), instanceId); }
		object I<#= ApiName#>.Get(<#= Type<Type>() #> type, string instanceId)
		{
	<# foreach(var model in GetInstanceModels) { #>
			
			if(type.IsAssignableFrom(typeof(<#= model.GetFullName(Mode.Concrete) #>)))
			{
				return new <#= model.GetFullName(Mode.Concrete) #>(rapplication.Get(instanceId, "<#= model.Id #>"));
			}
	<# } #>
	
			throw new GetInstanceException(type);
		}

		T I<#= ApiName #>.Get<T>() { return (T)((I<#= ApiName #>)this).Get(typeof(T)); }
		object I<#= ApiName #>.Get(<#= Type<Type>() #> type)
		{
	<# foreach(var model in SingletonModels) { #>

			if(type.IsAssignableFrom(typeof(<#= model.GetFullName(Mode.Concrete) #>)))
			{
				return new <#= model.GetFullName(Mode.Concrete) #>(rapplication.Get("<#= model.Type.StaticInstances[0].Id #>", "<#= model.Type.StaticInstances[0].ActualType.Id #>", "<#= model.Type.StaticInstances[0].ViewType.Id #>"));
			}
	<# } #>
	
	<# foreach(var model in InitializableOperationalModels) { #>
	
			if(type.IsAssignableFrom(typeof(<#= model.GetFullName(Mode.Factory) #>)))
			{
				return new <#= model.GetFullName(Mode.Factory) #>(rapplication);
			}
	<# } #>

			throw new SingletonException(type);
		}
	}
	
	public class GetInstanceException : <#= Type<Exception>() #>
	{
		public GetInstanceException(<#= Type<Type>() #> targetType) : base(string.Format("Cannot get instance for {0}. Given type should be non view type and rendered as interface.", targetType)) { }
	}

	public class SingletonException : <#= Type<Exception>() #>
	{
		public SingletonException(<#= Type<Type>() #> targetType) : base(string.Format("Given type {0} is not singleton", targetType)) { }
	}
}

<#+ 

protected string Type<T>() { return typeof(T).ToCSharpString(); }

#>